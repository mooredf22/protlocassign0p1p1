---
title: 'Vignette 3B: Data Transformations: Notation and Mixtures Using protlocassign'
author: "Dirk Moore"
date: "`r Sys.Date()`"
output:
  #html_document:
  #  toc: yes
  #  df_print: paged
  word_document:
    fig_caption: yes
    toc: yes
  #pdf_document:
  #  toc: yes
vignette: |
  %\VignetteIndexEntry{protlocassign} %\VignetteEngine{knitr::rmarkdown}
---


```{r setup, include = FALSE}
knitr::opts_chunk$set(
  #collapse = TRUE,
  comment = "",
  fig.width = 4,
  fig.height = 4,
	message = FALSE,
	warning = FALSE,
	tidy.opts = list(
		keep.blank.line = TRUE,
		width.cutoff = 150
		),
	options(width = 150),
	eval = TRUE
)
```


(Set up the data)
```{r, echo=TRUE, eval=TRUE}
library(protlocassign)
markerLocR <- cpaSetup(protProfileSummary=protProfileSummaryTMTms2, refLocProteins=refLocProteinsJadot, n.channels=9)
options(digits=2)
totProtUse <- tmtMS2totProt

protAbund <- relAmtTransform(markerLocR,6, totProt=totProtUse)
AcupMarkers <- protAbund$Acup
round(AcupMarkers, digits=3)
```


## Relative Specific Amounts

When examining the distribution of a given protein in different fractions, it is particularly useful to consider its abundance relative to that of total protein.  We refer to this as a Relative Specific Amount (RSA or $r$), which can be calculated as ${r_{\alpha ,l}} = a_{\alpha ,l}^*/t_l^*$, where ${{\textrm{t}}^*} = {\textrm{t}}/{t_h}$. This describes the fold-enrichment ($r>1$) or depletion ($r<1$) of a protein during the fractionation process, and is analogous to the relative specific activity term used in classical analytical subcellular fractionation.

Then the Relative Specific Amount (RSA) values represent the degree of enrichment or depletion of a protein in a given fraction compared to the amount in the starting material. For a protein $\alpha$ the RSA in fraction $l$ is given by

${r_{\alpha ,l}} = {{a_{\alpha ,l}^*} \over {t_l^*}} = {{{s_{\alpha ,l}} \cdot \sum\nolimits_j^k {{t_i}} } \over {\sum\nolimits_j^k {{s_{\alpha ,l}}{t_i}} }}$



In matrix form, this is $\mathbf{R}=\left( {{r}_{\alpha ,l}} \right)$.

In "protlocassign", we get the RSA matrix from "relAmtProtFrac" and "totProt" as follows:


```{r, echo=TRUE, eval=TRUE}
rsaMarkers <- RSAfromAcup(AcupMarkers, totProt=totProtUse)
round(rsaMarkers, digits=3)
```

Finally, if we normalize the rsa matrix so that rows sum to one (via the "apply" function), we get original input data, markerLocR
```{r, echo=TRUE, eval=TRUE}
round(t(apply(rsaMarkers,1, function(x) x/sum(x))), digits=3)
```

If we just need to obtain the RSA transformed data directly, just do this:
```{r, echo=TRUE, eval=TRUE}
markerLocRrsa <- RSAfromS(SS=markerLocR, NstartMaterialFractions=6,
        totProt=totProtUse)

round(markerLocRrsa, digits=3)
```

## Simulating proteins resident in multiple subcellular locations

We may simulate data from proteins with multiple residences using the `proteinMix` function. For example, to simulate date from proteins resident in a range of proportions in cytosol and lysosomes, we do this:

```{r, echo=TRUE, eval=TRUE}

protAbund <- relAmtTransform(markerLocR, NstartMaterialFractions=6, totProt=totProtUse)
AcupMarkers <- protAbund$Acup
mixCytoLyso <- proteinMix(AcupMarkers, Loc1=1, Loc2=4)
round(mixCytoLyso$mixAmount, digits=3)
```

The `proteinMix` function returns the mixture amounts in the `mixAmount` component and also the mixing information in the `mix.df` component. The latter shows the "true" simulated mixture proportions:

```{r, echo=TRUE, eval=TRUE}
round(mixCytoLyso$mix.df, digits=2)
```

Then we can test the CPA algorithm by first converting this mixture data to RSA's:

```{r, echo=TRUE, eval=TRUE}
mixCytoLysoRSA <- RSAfromAcup(Acup=mixCytoLyso$mixAmount, NstartMaterialFractions=6, totProt=totProtUse)

round(mixCytoLysoRSA, digits=3)

markerLocRrsa <- RSAfromAcup(Acup=AcupMarkers, NstartMaterialFractions=6, totProt=totProtUse)
```

Finally, we fit the CPA algorithm to this RSA-transformed, simulated data:

```{r, echo=TRUE, eval=TRUE}
mixCytoLysoProp <- proLocAll(protProfileSummary=mixCytoLysoRSA, markerLocR=markerLocRrsa,
                            n.channels=9)
round(mixCytoLysoProp, digits=3)
```


The estimated proportions correspond closely to the the proportions used in the simulation.

## Plotting mixtures of proteins with transformations

We may plot the predicted (based on CPA) and expected (based on the simulation parameters) proportional assignments using the `mixturePlot` function. We need to tell the program which locations were used to generate the mixtures using `Loc1` and `Loc2`:

```{r, echo=TRUE, eval=TRUE}
library(pracma)
mixturePlot(mixProtiProtjProp=mixCytoLysoProp, NstartMaterialFractions=6,
             Loc1=1, Loc2=4, xaxisLab=T, yaxisLab=T)
```

Here we see visually that the estimated proportions match the simulated ones. The area separated by the observed and expected CPA estimates is zero, which is shown in parentheses.

As an alternative, we may obtain CPA estimates using log-transformed relative amounts using `log2Transf=T`:

```{r, echo=TRUE, eval=TRUE}
mixCytoLysoRSAlog2 <- log2(mixCytoLysoRSA + .01)
markerLocRrsalog2 <- log2(markerLocRrsa + .01)

mixCytoLysoPropLog <- proLocAll(protProfileSummary=mixCytoLysoRSAlog2,
                              markerLocR=markerLocRrsalog2,
                            n.channels=9)
round(mixCytoLysoPropLog, digits=3)
mixturePlot(mixProtiProtjProp=mixCytoLysoPropLog, NstartMaterialFractions=6,
             Loc1=1, Loc2=4, xaxisLab=T, yaxisLab=T)

``` 

We see that the estimates are sub-optimal. The area between the observed and expected is 0.268.

## Effect of transformations on error rates for mixtures

Now we consider the effects of fitting CPA to mixtures using a variety of transformations. First, let us consider a mixture of Cyto with each of the other seven compartments in turn, using the ideal RSA-based transformations.


```{r, echo=TRUE, eval=TRUE, fig.show='hold', fig.width = 7, fig.height = 10}

#windows(height=10, width=7)
par(mfrow=c(4,2))  # create a 4 by 2 matrix of plots

i=1  # fix one component of the mixture to the first, which is Cyto
for (j in 2:8) {   # mix with each of the other compartments, and plot
   #j=4
   # Create mixture of subcellular locations i and j using "Acupmarkers"
   mixProtiProtj <- proteinMix(Acup=AcupMarkers, Loc1=i, Loc2=j)
 
   # Transform these mixtures to RSA
   mixProtiProtjRSA <- RSAfromAcup(Acup=mixProtiProtj$mixAmount, NstartMaterialFractions=6,  
                     totProt=totProtUse)
                     
   # Obtain CPA estimates from the RSA-transformed mixtures
   mixProtiProtjProp <- proLocAll(protProfileSummary=mixProtiProtjRSA,
                        markerLocR=markerLocRrsa, n.channels=9)
                            
   # Plot the results, including the area-based error estimate
   mixturePlot(mixProtiProtjProp=mixProtiProtjProp, NstartMaterialFractions=6,
             Loc1=i, Loc2=j)
             
}
```

All seven mixtures have zero error, as we expect. Next, consider a log2 transformation `y = log2(prop + 0.01)` of the RSA values before carrying out the CPA procedure.


```{r, echo=TRUE, eval=TRUE, fig.show='hold', fig.width = 7, fig.height = 10}

#windows(height=10, width=7)
par(mfrow=c(4,2))  # create a 4 by 2 matrix of plots

i=1  # fix one component of the mixture to the first, which is Cyto
for (j in 2:8) {   # mix with each of the other compartments, and plot
   #j=4
   # Create mixture of subcellular locations i and j using "Acupmarkers"
   mixProtiProtj <- proteinMix(Acup=AcupMarkers, Loc1=i, Loc2=j)
 
   # Transform these mixtures to RSA
   mixProtiProtjRSA <- RSAfromAcup(Acup=mixProtiProtj$mixAmount, NstartMaterialFractions=6,  
                     totProt=totProtUse)
   
   # Take a log2 transformation
   log2MixProtiProtjRSA <- log2(mixProtiProtjRSA + 0.01)
   log2MarkerLocRrsa <- log2(markerLocRrsa + 0.01)
                     
   # Obtain CPA estimates from the RSA-transformed mixtures
   mixProtiProtjProp <- proLocAll(protProfileSummary=log2MixProtiProtjRSA,
                        markerLocR=log2MarkerLocRrsa, n.channels=9)
                            
   # Plot the results, including the area-based error estimate
   mixturePlot(mixProtiProtjProp=mixProtiProtjProp, NstartMaterialFractions=6,
             Loc1=i, Loc2=j)
             
}
```



Now consider using normalized specific values, which is what we would use for these mixtures if the amounts of starting material in each fraction were not available. The first two function calls are as above, but we obtain these normalized specific values by constraining the RSA values to sum to 1 before using `proLocAll` with `markerLocRuse' to compute the CPA estimates.


```{r, echo=TRUE, eval=TRUE, fig.show='hold', fig.width = 7, fig.height = 10}

#windows(height=10, width=7)
par(mfrow=c(4,2))  # create a 4 by 2 matrix of plots

i=1  # fix one component of the mixture to the first, which is Cyto
for (j in 2:8) {   # mix with each of the other compartments, and plot
   #j=4
   # Create mixture of subcellular locations i and j using "Acupmarkers"
   mixProtiProtj <- proteinMix(Acup=AcupMarkers, Loc1=i, Loc2=j)
 
   # Transform these mixtures to RSA
   mixProtiProtjRSA <- RSAfromAcup(Acup=mixProtiProtj$mixAmount, NstartMaterialFractions=6,  
                     totProt=totProtUse)
   
   # Now convert to normalized specific values
   mixProtiProtjSpecific <- t(apply(mixProtiProtjRSA,1, function(x) x/sum(x)))
                     
   # Obtain CPA estimates from the RSA-transformed mixtures
   mixProtiProtjProp <- proLocAll(protProfileSummary=mixProtiProtjSpecific,
                        markerLocR=markerLocR, n.channels=9)
                            
   # Plot the results, including the area-based error estimate
   mixturePlot(mixProtiProtjProp=mixProtiProtjProp, NstartMaterialFractions=6,
             Loc1=i, Loc2=j)
             
}
```

Finally we consider log2-transformed values of normalized specific values. This set of plots is similar to the last one except a transformation `y = log2(prop + 0.01)` is applied before obtaining CPA estimates.


```{r, echo=TRUE, eval=TRUE, fig.show='hold', fig.width = 7, fig.height = 10}

#windows(height=10, width=7)
par(mfrow=c(4,2))  # create a 4 by 2 matrix of plots

i=1  # fix one component of the mixture to the first, which is Cyto
for (j in 2:8) {   # mix with each of the other compartments, and plot
   #j=4
   # Create mixture of subcellular locations i and j using "Acupmarkers"
   mixProtiProtj <- proteinMix(Acup=AcupMarkers, Loc1=i, Loc2=j)
 
   # Transform these mixtures to RSA
   mixProtiProtjRSA <- RSAfromAcup(Acup=mixProtiProtj$mixAmount, NstartMaterialFractions=6,  
                     totProt=totProtUse)
   
   # Now convert to normalized specific values
   mixProtiProtjSpecific <- t(apply(mixProtiProtjRSA,1, function(x) x/sum(x)))
   log2MixProtiProtjSpecific <- log2(mixProtiProtjSpecific + 0.01)
   log2MarkerLocR <- log2(markerLocR + 0.01)
                     
   # Obtain CPA estimates from the RSA-transformed mixtures
   mixProtiProtjProp <- proLocAll(protProfileSummary=log2MixProtiProtjSpecific,
                        markerLocR=log2MarkerLocR, n.channels=9)
                            
   # Plot the results, including the area-based error estimate
   mixturePlot(mixProtiProtjProp=mixProtiProtjProp, NstartMaterialFractions=6,
             Loc1=i, Loc2=j)
             
}
```

 






