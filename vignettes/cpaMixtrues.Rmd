---
title: "CPA mixtures - lysosome and cytosol"
author: "Dirk Moore"
date: "`r Sys.Date()`"
output: word_document
---

This is an illustration of simulating proteins that are mixtures of residence in the cytosol and lysosome, using the Jadot et al. (2016) data. This data set includes the fractions N, M, L1, L2, P and S, and also the Nyc2 component, for a total of 7 channels.

The reference proteins are in "matLocR":

```{r, echo=TRUE}
# create mixtures

library(protlocassign)

matLocR <- cpaSetup(geneProfileSummary=geneProfileSummaryJadotExptA, refLocProteins=refLocProteinsJadot, n.channels=7)
round(matLocR, digits=4)
```

We convert these first to protein abundance ("yellow" in the Lobel Excel spreadsheet) and then relative abundance ("red" in the Lobel Excel spreadsheet).
```{r, echo=TRUE}
totProt=c(46.044776, 48.955954, 1.384083, 1.566324, 24.045584, 58.181818, 0.0684596)
protAbund <- abundanceTransform(matLocR, 6,1 , totProt=totProt)
relAmtProtFrac <- protAbund$relAmtProtFrac
round(relAmtProtFrac, digits=4)
```

Mixtures are created in fractions from 0 to 1, in increments of 0.1, using "relAmtProtFrac".

```{r, echo=TRUE}
mixCytoLyso <- proteinMix(relAmtProtFrac, 1, 4)
round(mixCytoLyso, digits=4)
```

These mixtures are then transformed to relative specific activity.

```{r, echo=TRUE}
mixCytoLysoRSAdata <- RSAtransform(relAmtProtFrac=mixCytoLyso, nDiffFractions=6, nNycFractions=3, totProt=totProt)$rsa

mixCytoLysoRSA <- data.frame(rownames(mixCytoLysoRSAdata), mixCytoLysoRSAdata)
names(mixCytoLysoRSA)[1] <- "geneName"
round(mixCytoLysoRSA[,-1], digits=4)
```

The reference proteins, "matLocR" are also transformed to the rsa values:
```{r, echo=TRUE}
matLocRrsa <- rsaDirect(geneProfileLevels=matLocR, nDiffFractions=6, nNycFractions=1, totProt=totProt, maxRSA=25)
rownames(matLocRrsa) <- rownames(matLocR)
round(matLocRrsa, digits=4)
```

Finally, we fit the CPA procedure to the RSA-transformed data, using the RSA-transformed reference values
```{r, echo=TRUE}
cpaOutT <- proLocAll(geneProfileSummary=mixCytoLysoRSA, matLocR=matLocRrsa,
          n.channels=7)
data.frame(cpaOutT[,1], round(cpaOutT[,2:8], digits=4))
```
The fitted proportions match the created ones perfectly

# Now compute what would have been the original input data:
```{r, echo=TRUE}
rsa <- mixCytoLysoRSA[,2:8]
rsaFractionsT <- t(apply(rsa,1, function(x) x/sum(x)))
rsaFractions <- data.frame(mixCytoLysoRSA[,1], rsaFractionsT)
names(rsaFractions)[1] <- "geneName"
round(rsaFractionsT, digits=4)
```

# Now run CPA on these
```{r, echo=TRUE}
cpa2outT <- proLocAll(geneProfileSummary=rsaFractions, matLocR=matLocR, n.channels=7)
cpa2out <- cpa2outT[,2:8]
rownames(cpa2out) <- cpa2outT$geneName
round(cpa2out, digits=4)
```
These are the estimates that would have been found if we had applied the RSA procedure to the amounts measured in the untransformed output, constrained to sum to 1.
