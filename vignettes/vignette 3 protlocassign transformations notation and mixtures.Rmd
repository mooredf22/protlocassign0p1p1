---
title: 'Vignette 3: Data Transformations: Notation and Mixtures Using protlocassign'
author: "Dirk Moore"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: yes
    df_print: paged
  word_document:
    fig_caption: yes
    toc: yes
  pdf_document:
    toc: yes
vignette: |
  %\VignetteIndexEntry{protlocassign} %\VignetteEngine{knitr::rmarkdown}
---


```{r setup, include = FALSE}
knitr::opts_chunk$set(
  #collapse = TRUE,
  comment = "",
  fig.width = 4,
  fig.height = 4,
	message = FALSE,
	warning = FALSE,
	tidy.opts = list(
		keep.blank.line = TRUE,
		width.cutoff = 150
		),
	options(width = 150),
	eval = TRUE
)
```

## Adjustment of protein abundance levels

The input data, protProfileSummary, consists of a list of protein names (first column) and the relative abundance (technically, the "specific amount", which reflects the signal in arbitrary units per unit total protein) of the corresponding proteins in the next columns. Typically, there will be six differential fraction columns (N, M, L1, L2, P, and S) and one to three additional Nycodenz fractions (which have been extracted from the L1 differential fraction). These quantities represent the specific amounts of a protein in each fraction. The amounts (denoted $t_l$) of protein extracted from each fraction, (R variable "totProtein"), differ dramatically from one fraction to another. Notably, the L1 and L2 fractions, which are heavily enriched in lysosomal and peroxixomal proteins, contain much smaller amounts of protein than the other differential fractions. Also, the samples used for the Nycodenz fractionization are taken from the L1 fraction, so they also represent very small proportions of the total sample. For technical reasons, when samples of material are prepared for analysis, equal amounts are selected for each channel, regardless of the amount of protein in the fractions. As a result, when the data are analyzed, adjustments need to be made in order to obtain meaningful comparisons.

Consider an $n$ by 9 matrix that details the average distribtuion of $n$ proteins (or other species of interest) among 9 fractions:
$$
S=\left[ \begin{matrix}
   {{s}_{11}} & {{s}_{12}} & \cdots  & {{s}_{19}}  \\
   {{s}_{21}} & {{s}_{22}} & \cdots  & {{s}_{29}}  \\
   \vdots  & \vdots  & {} & \vdots   \\
   {{s}_{n1}} & {{s}_{n2}} & \cdots  & {{s}_{n9}}  \\
\end{matrix} \right]
$$

Each row $\alpha$ represents a mean profile for a protein or other species of interest $\alpha$, with each profile consisting of $f=9$ fractions. For $i$

In the introductory vignette we actually used a normalized specific amount $\overset{\sim} s_l$ (generally the amount of signal in that fraction), calculated as follows:


$$ {{\tilde{s}}_{\alpha ,l}}=\frac{{{s}_{\alpha ,l}}}{\sum\limits_{j=1}^{f}{{{s}_{\alpha ,j}}}} $$
In some experiments, where bookkeeping is not practicable, these are the only values available for using the CPA procedure. However, with appropriate bookkeeping, the amounts of total protein, $t_l$, are available. We can use these to calculate the amount of protein in fraction $l$ derived from a set amount of starting material as $a_l = s_l t_l$.

  To see how this works in protlocassign, let us consider the Jadot reference protein profiles

```{r, echo=TRUE, eval=TRUE}
library(protlocassign)
markerLocR <- cpaSetup(protProfileSummary=protProfileSummaryTMTms2, refLocProteins=refLocProteinsJadot, n.channels=9)
round(markerLocR, digits=3)

```

Here, each row represents the profile $\overset{\sim} s_l$ for a protein resident solely in a particular compartment. The amount of starting material, tmtMS2totProt, ($t_l$) in each fraction is as follows:

```{r, echo=TRUE, eval=TRUE}

totProtUse <- tmtMS2totProt
totProtUse

totProtdf <- data.frame(t(matrix(totProtUse)))
names(totProtdf) <- colnames(markerLocR)
totProtdf
```

We denote these values using a vector ${\bf t} = (t_1, t_2, \dots, t_9)$. The total amount of starting material ${{t}_{h}}=\sum\limits_{i=1}^{6}{{{t}_{i}}}$ is the sum of the amounts given in the first six (differential) fractions (N, M, L1, L2, P, and S).

```{r, echo=TRUE, eval=TRUE}
sum(totProtUse[1:6])
```

(The last three "Nyc" columns were derived from L1, so we do not include them in the sum.)

The next step is to compute the amount of protein in each fraction fraction by multiplying the normalized specific amount by the total protein. Thus for protein $\alpha$ in fraction $l$, we have ${{a}_{\alpha ,l}}={{\tilde{s}}_{\alpha ,l}}{{t}_{l}}$. In matrix form,

$$\mathbf{A}=\mathbf{\tilde{S}}\cdot \text{diag}(\mathbf{t})=\left[ \begin{matrix}
   {{{\tilde{s}}}_{11}}{{t}_{1}} & {{{\tilde{s}}}_{12}}{{t}_{2}} & \cdots  & {{{\tilde{s}}}_{19}}{{t}_{9}}  \\
   {{{\tilde{s}}}_{21}}{{t}_{1}} & {{{\tilde{s}}}_{22}}{{t}_{2}} & \cdots  & {{{\tilde{s}}}_{29}}{{t}_{9}}  \\
   \vdots  & \vdots  & {} & \vdots   \\
   {{{\tilde{s}}}_{n1}}{{t}_{1}} & {{{\tilde{s}}}_{n2}}{{t}_{2}} & \cdots  & {{{\tilde{s}}}_{n9}}{{t}_{9}}  \\
\end{matrix} \right]$$

We need this matrix to do the next step, which is to convert to a common scale for all proteins. We do this by normalizing to the amount of protein $\alpha$ in the starting material, which we denote as $a_{\alpha, h}$. In some experiments, if the homogenate is measured directly, this can be calculated from ${{s}_{\alpha ,h}}{{t}_{h}}$.
Alternatively, if a complete set of fractions that entirely represent the homogenate are available, it is preferable to calculate this by summing $s_{\alpha,l}t_l$ over these fractions. In our case, the first six fractions represent a complete set of differential fractions, and thus ${a_{\alpha ,h}} = \sum\nolimits_{i = 1}^6 {{s_{\alpha ,i}}{t_i}} $. Finally, we normalize amounts in any given fraction to amounts in starting material, which we call the relative amount and denote as $a_{\alpha ,l}^*$. In our example,

$$a_{\alpha ,l}^* = \frac{{{s_{\alpha ,l}}{t_l}}}{{{s_{\alpha ,h}}{t_h}}} = \frac{{{s_{\alpha ,l}}{t_l}}}{{\sum\nolimits_{i = 1}^6 {{s_{\alpha ,i}}{t_i}} }} = \frac{{{{\tilde s}_{\alpha ,l}}{t_l}}}{{\sum\nolimits_{i = 1}^6 {{{\tilde s}_{\alpha ,i}}{t_i}} }}$$


In matrix form, we may write this as 

$${{\bf{A}}^*} = {\bf{A}} \cdot {\rm{diag}}(1/{a_{\alpha ,h}}) = \left[ {\begin{array}{*{20}{c}}
{{s_{11}}{t_1}/{a_{1,h}}}&{{s_{12}}{t_2}/{a_{1,h}}}& \cdots &{{s_{19}}{t_9}/{a_{1,h}}}\\
{{s_{21}}{t_1}/{a_{2,h}}}&{{s_{22}}{t_2}/{a_{2,h}}}& \cdots &{{s_{29}}{t_9}/{a_{2,h}}}\\
 \vdots & \vdots &{}& \vdots \\
{{s_{n1}}{t_1}/{a_{n,h}}}&{{s_{n2}}{t_2}/{a_{n,h}}}& \cdots &{{s_{n9}}{t_9}/{a_{n,h}}}
\end{array}} \right]$$


or simply as  ${{\bf{A}}^*} = (a_{\alpha ,l}^*)$.

The function abundanceTransform computes this:



```{r, echo=TRUE, eval=TRUE}

protAbund <- relAmtTransform(markerLocR,6, totProt=totProtUse)
AcupMarkers <- protAbund$Acup
round(AcupMarkers, digits=3)
```

The values in "relAmtProtFrac" represent the amount of protein per fraction, normalized to same amount of protein in the starting material (before mixing). In theory, these values correspond approximately to the relative amounts of protein in compartments within a cell.

##Relative Specific Amounts

When examining the distribution of a given protein in different fractions, it is particularly useful to consider its abundance relative to that of total protein.  We refer to this as a Relative Specific Amount (RSA or $r$), which can be calculated as ${r_{\alpha ,l}} = a_{\alpha ,l}^*/t_l^*$, where ${{\bf{t}}^*} = {\bf{t}}/{t_h}$. This describes the fold-enrichment ($r>1$) or depletion ($r<1$) of a protein during the fractionation process, and is analogous to the relative specific activity term used in classical analytical subcellular fractionation.

Then the Relative Specific Amount (RSA) values represent the degree of enrichment or depletion of a protein in a given fraction compared to the amount in the starting material. For a protein $\alpha$ the RSA in fraction $l$ is given by

$${r_{\alpha ,l}} = {{a_{\alpha ,l}^*} \over {t_l^*}} = {{{s_{\alpha ,l}} \cdot \sum\nolimits_j^k {{t_i}} } \over {\sum\nolimits_j^k {{s_{\alpha ,l}}{t_i}} }}$$

In matrix form, this is $\mathbf{R}=\left( {{r}_{\alpha ,l}} \right)$.

In "protlocassign", we get the RSA matrix from "relAmtProtFrac" and "totProt" as follows:


```{r, echo=TRUE, eval=TRUE}
rsaMarkers <- RSAfromAcup(AcupMarkers, totProt=totProtUse)
round(rsaMarkers, digits=3)
```

Finally, if we normalize the rsa matrix so that rows sum to one (via the "apply" function), we get original input data, markerLocR
```{r, echo=TRUE, eval=TRUE}
round(t(apply(rsaMarkers,1, function(x) x/sum(x))), digits=3)
```

If we just need to obtain the RSA transformed data directly, just do this:
```{r, echo=TRUE, eval=TRUE}
markerLocRrsa <- RSAfromS(SS=markerLocR, NstartMaterialFractions=6,
        totProt=totProtUse)

round(markerLocRrsa, digits=3)
```

## Simulating proteins resident in multiple subcellular locations

We may simulate data from proteins with multiple residences using the `proteinMix` function. For example, to simulate date from proteins resident in a range of proportions in cytosol and lysosomes, we do this:

```{r, echo=TRUE, eval=TRUE}

protAbund <- relAmtTransform(markerLocR, NstartMaterialFractions=6, totProt=totProtUse)
AcupMarkers <- protAbund$Acup
mixCytoLyso <- proteinMix(AcupMarkers, Loc1=1, Loc2=4)
round(mixCytoLyso$mixAmount, digits=3)
```

The `proteinMix` function returns the mixture amounts in the `mixAmount` component and also the mixing information in the `mix.df` component. The latter shows the "true" simulated mixture proportions:

```{r, echo=TRUE, eval=TRUE}
round(mixCytoLyso$mix.df, digits=2)
```

Then we can test the CPA algorithm by first converting this mixture data to RSA's:

```{r, echo=TRUE, eval=TRUE}
mixCytoLysoRSAtemp <- RSAfromAcup(Acup=mixCytoLyso$mixAmount, NstartMaterialFractions=6, totProt=totProtUse)

mixCytoLysoRSA <- data.frame(rownames(mixCytoLysoRSAtemp), mixCytoLysoRSAtemp)
names(mixCytoLysoRSA)[1] <- "protName"
round(mixCytoLysoRSA[,-1], digits=3)

#markerLocRrsa <- rsaDirect(protProfileLevels=markerLocR, totProt=totProt)
markerLocRrsa <- RSAfromAcup(Acup=AcupMarkers, NstartMaterialFractions=6, totProt=totProtUse)
#markerLocRrsa <- RSAfromS(SS=markerLocR, NstartMaterialFractions=6, totProt=totProtUse)
#rownames(markerLocRrsa) <- rownames(markerLocR)
```

Finally, we fit the CPA algorithm to this RSA-transformed, simulated data:

```{r, echo=TRUE, eval=TRUE}
mixCytoLysoPropT <- proLocAll(protProfileSummary=mixCytoLysoRSA, markerLocR=markerLocRrsa,
                            n.channels=9)
```

To get the data only, we remove column 1 ("protein" names):

```{r, echo=TRUE, eval=TRUE}
mixCytoLysoProp <- mixCytoLysoPropT[,-1]
row.names(mixCytoLysoProp) <- mixCytoLysoPropT[,1]
round(mixCytoLysoProp, digits=3)

```

The estimated proportions correspond closely to the the proportions used in the simulation.

## Plotting mixtures of proteins with transformations

We may plot the predicted (based on CPA) and expected (based on the simulation parameters) proportional assignments using the `mixturePlot` function. We need to tell the program which locations were used to generate the mixtures using `Loc1` and `Loc2`:

```{r, echo=TRUE, eval=TRUE}
library(pracma)
mixturePlot(mixProtiProtjProp=mixCytoLysoProp, NstartMaterialFractions=6,
             Loc1=1, Loc2=4, xaxisLab=T, yaxisLab=T)
```

Here we see visually that the estimated proportions match the simulated ones. The area separated by the observed and expected CPA estimates is zero, which is shown in parentheses.

As an alternative, we may obtain CPA estimates using log-transformed relative amounts using `log2Transf=T`:

```{r, echo=TRUE, eval=TRUE}
mixCytoLysoRSAlog2 <- cbind(mixCytoLysoRSA[,1], log2(mixCytoLysoRSA[,-1] + .01))
names(mixCytoLysoRSAlog2)[1] <- "protName"
markerLocRrsalog2 <- log2(markerLocRrsa + .01)
#mixCytoLysoRelAmtLog2 <- mixCytoLysoRelAmt
#mixCytoLysoRelAmtLog2[,-1],  <- log2(mixCytoLysoRelAmt[,-1] + .01)
mixCytoLysoPropT <- proLocAll(protProfileSummary=mixCytoLysoRSAlog2,
                              markerLocR=markerLocRrsalog2,
                            n.channels=9)
mixCytoLysoPropLog <- mixCytoLysoPropT[,-1]
row.names(mixCytoLysoPropLog) <- mixCytoLysoPropT[,1]
round(mixCytoLysoPropLog, digits=3)
mixturePlot(mixProtiProtjProp=mixCytoLysoPropLog, NstartMaterialFractions=6,
             Loc1=1, Loc2=4, xaxisLab=T, yaxisLab=T)

```

We see that the estimates are sub-obtimal. The area between the observed and expected is 0.268.

## Miscellaneous bits

 #i=1
  #j=4
  #mixCytoLyso <- proteinMix(relAmtProtFrac, Loc1=i, Loc2=j)
  n.channels <- ncol(Acup)
  mixProtiProtj <- proteinMix(Acup=Acup, Loc1=Loc1, Loc2=Loc2)
  #mixCytoLyso

  mixProtiProtjRSA <- RSAfromAcup(Acup=mixProtiProtj, NstartMaterialFractions=6, totProt=totProtUse)

  mixProtiProtjRelAmt <- data.frame(rownames(mixProtiProtjRSA), mixProtiProtjRSA)
  names(mixProtiProtjRelAmt)[1] <- "protName"
  round(mixProtiProtjRelAmt[,-1], digits=4)




  if (type == "relAmt") {
    #cpaOutT <- proLocAll(geneProfileSummary=mixCytoLysoRelAmt, matLocR=matLocRrsa,
    #      n.channels=7, log2Transf=log2Transf)
    cpaOutT <- proLocAll(protProfileSummary=mixProtiProtjRelAmt, markerLocR=markerLocRrsa,
                         n.channels=n.channels, log2Transf=log2Transf)
    #cpaOutT
    # the fitted proportions match the created ones perfectly
    cpaOutData <- cpaOutT[,-1]
  }


  # Now compute what would have been the original input data:
  if (type == "original") {
    #rsa <- mixCytoLysoRelAmt[,2:8]
    rsa <- mixProtiProtjRelAmt[,2:10]
    rsaFractionsT <- t(apply(rsa,1, function(x) x/sum(x)))
    #rsaFractions <- data.frame(mixCytoLysoRelAmt[,1], rsaFractionsT)
    rsaFractions <- data.frame(mixProtiProtjRelAmt[,1], rsaFractionsT)
    names(rsaFractions)[1] <- "protName"

    # Now run CPA on these

    cpaOutT <- proLocAll(protProfileSummary=rsaFractions, markerLocR=markerLocRuse, n.channels=n.channels, log2Transf=log2Transf)
    cpaOutData <- cpaOutT[,-1]
  }

