---
title: "Vignette 2: Data Transformations Using protlocassign"
author: "Dirk Moore"
date: "`r Sys.Date()`"
#output: rmarkdown::html_vignette
output:
  #mathjax:  default
  #  html_document:
  word_document:
  fig_caption:  true
  toc: true
#section_numbering: true
#css: ggsci.css
#output:
#  word_document:
#    reference_docx: word-styles-reference-03.docx
#output: pdf_document
#fontsize: 10pt
vignette: >
  %\VignetteIndexEntry{protlocassign}
  %\VignetteEngine{knitr::rmarkdown}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  #collapse = TRUE,
  comment = "",
  fig.width = 4,
  fig.height = 4,
	message = FALSE,
	warning = FALSE,
	tidy.opts = list(
		keep.blank.line = TRUE,
		width.cutoff = 150
		),
	options(width = 150),
	eval = TRUE
)
```



## Data transformations

In Vignette 1 (“Getting Started”) we illustrated the principles of constrained proportional assignment using protein profiles that represent normalized mass spectrometry data from a set of subcellular fractions.  This vignette describes how to use functions in the protlocassign package to transform such profiles in a manner that is more useful for inferring proportional residence in subcellular compartments.


## Loading the data

As explained in the Vignette 1, as an example we will use two R data sets that are included in the `protlocassign` package.  One, `protProfileSummaryTMTms2`, consists of a column of protein names followed by nine columns of normalized relative specific amounts derived from a subcellular fractionation experiment. The other, `refLocProteinsJadot`, consists of a list of reference proteins that serve as markers for different subcellular compartments in the first column and the name of the subcellular compartment in the second column.  As before, to run the program, the `protlocassign` library must be installed. 



```{r, echo=TRUE}
library(protlocassign)
```

In Vignette 1, we use `protProfileSummaryTMTms2` and an untransformed average of reference proteins for each compartment to conduct CPA. However, it may be advantageous to transform the data prior to conducting CPA to yield a more accurate prediction of cellular location.  For this purpose, we express profile data as relative specific amounts (RSAs).  As explained in the main text and elaborated in the Appendix, RSA is the ratio of two ratios:  the numerator is the amount of a given protein in a particular fraction divided by the amount of that given protein in the starting material while the denominator is amount of total protein in a particular fraction divided by the amount of total protein in the starting material.  Be aware that to perform this transformation, one needs to have estimates of all these quantities, and this was incorporated into our experimental design.  In our example, the first six fractions (the differential fractions) can be used to estimate amounts in the starting material.  We also measured total protein in each fraction, and these are contained in the 9-element vector `tmtMS2totProt` which is preloaded in `protlocassign`.  Note that the order of the measurements for total protein (e.g., N, M, L1, L2, P, S, Nyc1, Nyc2 and Nyc3 in `tmtMS2totProt`) must correspond to those in the data set containing individual protein profiles (e.g., `protProfileSummaryTMTms2`).

```{r, echo=TRUE, eval=TRUE, fig.show='hold'}
totProtUse <- tmtMS2totProt
totProtUse
```

The function `RSAfromS` calculates transformed profiles from individual and total protein measurements.  This requires specifying which values are used to estimate the amount in the starting material (typically homogenate) and the values used to construct the profile.  In our case, the first six fractions of the nine-fraction profile are summed to estimate the starting material.  


```{r, echo=TRUE, eval=TRUE, fig.show='hold'}
protProfileLevelsUse <- protProfileSummaryTMTms2[,2:(1 + 9)]
protProfileLevelsRSA <- RSAfromS(SS=protProfileLevelsUse,
                                   nDiffFractions=6, nNycFractions=3, totProt=totProtUse)
dim(protProfileLevelsRSA)
str(protProfileLevelsRSA)
```

Now we put back the protein names in the first column, and Nspectra and Nseq in the last columns:

```{r, echo=TRUE, eval=TRUE, fig.show='hold'}
protProfileSummaryRSA <- data.frame(protProfileSummaryTMTms2[,1],protProfileLevelsRSA,
                                    protProfileSummaryTMTms2[,11:12])
names(protProfileSummaryRSA)[1] <- "protName"
dim(protProfileSummaryRSA)
str(protProfileSummaryRSA)
```

We also need to transform the profiles of the markers for each compartment.  As done in Vignette 1, we use the function `cpaSetup` to average the profiles (which must be normalized specific amounts).  We then use `RSAfromS` to transform these reference profiles.



To obtain profiles for the reference proteins, use the function `cpaSetup`:

```{r, echo=TRUE, eval=TRUE}
markerLocRuse <- cpaSetup(protProfileSummary=protProfileSummaryTMTms2, refLocProteins=refLocProteinsJadot, n.channels=9)
markerLocRuse

```

We then use `RSAfromS` to transform these reference profiles.

```{r, echo=TRUE, eval=TRUE, fig.show='hold'}
markerLocRrsa <- RSAfromS(SS=markerLocRuse, nDiffFractions=6,
       nNycFractions=3, totProt=totProtUse)
row.names(markerLocRrsa) <- row.names(markerLocRuse)

```

Now we can plot the reference profile for any subcellular location on the RSA scale. For example, here is the plot for PM:


```{r, echo=TRUE, eval=TRUE, fig.show='hold'}
refProfilePlot(refLoc="PM", refLocProteins=refLocProteinsJadot,
                     protProfileSummary=protProfileSummaryRSA,
                     markerLocR=markerLocRrsa)

```

Now we can run the CPA routine on the RSA-transformed levels; this may take several minutes to complete. The last column is a convergence indicator, with 1 indicating successful convergence. We remove this last column to get a matrix of protein names, and columns indicating the estimated proportional assignments of each protein among the eight subcellular locations.

```{r, echo=TRUE, eval=TRUE}
assignPropsOutTemp <- proLocAll(protProfileSummary=protProfileSummaryRSA,
                                markerLocR=markerLocRrsa, n.channels=9)
ncol.a <- ncol(assignPropsOutTemp)   # last column is a convergence indicator, which should be 1
assignPropsUse <- data.frame(assignPropsOutTemp[,-ncol.a] ) # drop this last column
str(assignPropsUse)
```

                   

The horizontal axis represents the nine fractions, which are N, M, L1, L2, P, S, Nyc.1, Nyc.2, and Nyc.3. In each of the eight plots, the red line is the average profile of the protein. The dashed yellow-black lines show the expected profile for a protein entirely resident in the respective subcellular location. In this set of plots, we see that the CPA procedure assigns a 59 percent residence proportion to plasma membrane and 35 percent residence to cytosol. Visually, we see that the observed red profile closely matches a mixture of the expected yellow-blacklines. 

The `protPlotfun` function is designed to plot profiles of eight subcellular locations. If a data set has more than eight of these, it will be necessary to modify the code to accommodate the larger number.











# Appendix
## Outlier rejection and computation of mean profiles

The profiles of some compartments (e.g. nuclear and mitochondrial) show a high relative abundance level in the N or M fractions, respectively, and little in the others. Cytosolic proteins also are high in one fraction (S) and low in the others. Peroxisomes have high activity levels in the L1 and L2 fractions, and low levels in the others, including Nyc2. Lysosomes, like peroxisomes, have high level in the L1 and L2 fractions, but, unlike peroxisomes, high levels in Nyc2. The other compartments (ER, Golgi, and PM) have more complex profiles. Once we have obtained reference profiles for each of the eight compartments, we score each new protein as the optimal combination of the reference proteins, thereby obtaining estimates of the proportionate contributions of each reference profile to that of the protein being considered.


The first step is an outlier screen, for each protein, of the abundance levels for each fraction of all of the spectra. Abundance levels $p$ are first log2 transformed via $y = log_2(p + \delta)$, where $\delta$ is an estimate of the background "noise" in the abundance estimates. Here we used $\delta = 10^{(-5)}$. Then boxplot outliers are identified as values more than three times the interquartile range beyond the first or third quartile. We discard any spectrum for which any observation is thereby classified as an outlier. This process is repeated for all proteins.


## Constrained proportional assignment
Once outlier spectra have been removed, the next step is to determine a mean profile for each protein. If a protein has at least 4 spectra and at least 3 different sequences (peptides), we ordinarily have enough data to fit a random effects model. This model computes, for each EF in each fraction of this protein, a weighted average and standard error of the measures, accounting for the fact that spectra are nested within sequences. (This computation is carried out using the “lmer” function in the “lme4” R package.) . The result is essentially the mean and standard error of the observations, with an adjustment for the nested structure of the data. This procedure prevents a sequence with a very large number of spectra from dominating the estimates of the mean and standard error.  Occasionally the “lmer” program will fail to converge for a particular abundance. If that happens or if the condition of having at least 4 spectra and 3 different sequences is not met, we compute the simple mean and standard error of the (log2 transformed) for that abundance level. If there are fewer than 3 spectra, we cannot compute a standard error, and thus only report the mean.  When this process has been completed, every protein has a mean profile which for now we denote as $\underset{\sim}x = (x_1, x_2, ..., x_q)$  of abundance levels in the $q=9$ fractions N, M, L1, L2, P, S, Nyc1, Nyc2, and Nyc3. Below we will see that the abundance levels $x_j$ may be represented as either the amount of species of interest (typically a protein) measured in a channel or, if a process known as bookkeeping has been followed, the relative specific amounts of that species of interest. For proteins with at least 2 peptides and three spectra, each component of the profile has an estimate of its standard deviation.

Next, the profiles of the reference proteins are selected. For each of the eight compartments (Cytosol, ER, Golgi, Lysosome, Mitochondria, Nucleus, Peroxisome, and PM), the reference protein abundance levels are averaged to form eight compartment profiles $\underset{\sim}x^*_1, \underset{\sim}x^*_2, ..., \underset{\sim}x^*_8$, where each vector $\underset{\sim}x^*_j$ is a $q \times 1$ vector of mean levels of the $q=9$ channels.

Finally, for each protein, we find estimated proportions $\hat{p}_1, \hat{p}_2, ..., \hat{p}_8$ so that
$$\underset{\sim}y = \hat{p}_1 \underset{\sim}x^*_1 + ...+ \hat{p}_8 \underset{\sim}x^*_8$$
is as close as possible to the observed value $\underset{\sim}x$, subject to the constraints

$$ 0 \leq \hat{p_j} \leq 1$$

for all $j$, and



$$ \sum_{j=1}^{8} \hat{p}_j = 1 $$
where "close" is defined by minimizing the sum of squares of the differences

$$ \psi(p_1, p_2, \dots, p_g) =\sum_{i=1}^{q}(y_i - x_i)^2 $$
Thus, we may view the proportions $\hat{p}_j$ as proportional allocations of the eight standard profiles to form $\underset{\sim}y$, which is as close as possible to the observed $\underset{\sim}x$ for this particular protein. This constrained optimization is carried out using the “spg” function in the R package “BB” to compute assignment probabilities for each profile for each organelle.

## Adjustment of protein abundance levels

The input data, protProfileSummary, consists of a list of protein names (first column) and the relative abundance (technically, the "specific amount", which reflects the signal in arbitrary units per unit total protein) of the corresponding proteins in the next columns. Typically, there will be six differential fraction columns (N, M, L1, L2, P, and S) and one to three additional Nycodenz fractions (which have been extracted from the L1 differential fraction). These quantities represent the specific amounts of a protein in each fraction. The amounts (denoted $t_l$) of protein extracted from each fraction, (R variable "totProtein"), differ dramatically from one fraction to another. Notably, the L1 and L2 fractions, which are heavily enriched in lysosomal and peroxixomal proteins, contain much smaller amounts of protein than the other differential fractions. Also, the samples used for the Nycodenz fractionization are taken from the L1 fraction, so they also represent very small proportions of the total sample. For technical reasons, when samples of material are prepared for analysis, equal amounts are selected for each channel, regardless of the amount of protein in the fractions. As a result, when the data are analyzed, adjustments need to be made in order to obtain meaningful comparisons. 

Consider an $n$ by 9 matrix that details the average distribtuion of $n$ proteins (or other species of interest) among 9 fractions:
$$
S=\left[ \begin{matrix}
   {{s}_{11}} & {{s}_{12}} & \cdots  & {{s}_{19}}  \\
   {{s}_{21}} & {{s}_{22}} & \cdots  & {{s}_{29}}  \\
   \vdots  & \vdots  & {} & \vdots   \\
   {{s}_{n1}} & {{s}_{n2}} & \cdots  & {{s}_{n9}}  \\
\end{matrix} \right]
$$

Each row $\alpha$ represents a mean profile for a protein or other species of interest $\alpha$, with each profile consisting of $f=9$ fractions. For $i$

In the introductory vignette we actually used a normalized specific amount $\overset{\sim} s_l$ (generally the amount of signal in that fraction), calculated as follows:


$$ {{\tilde{s}}_{\alpha ,l}}=\frac{{{s}_{\alpha ,l}}}{\sum\limits_{j=1}^{f}{{{s}_{\alpha ,j}}}} $$
In some experiments, where bookkeeping is not practicable, these are the only values available for using the CPA procedure. However, with appropriate bookkeeping, the amounts of total protein, $t_l$, are available. We can use these to calculate the amount of protein in fraction $l$ derived from a set amount of starting material as $a_l = s_l t_l$.

  To see how this works in protlocassign, let us consider the Jadot reference protein profiles

```{r, echo=TRUE, eval=TRUE}
markerLocR <- cpaSetup(protProfileSummary=protProfileSummaryTMTms2, refLocProteins=refLocProteinsJadot, n.channels=9)
round(markerLocR, digits=4)

```

Here, each row represents the profile $\overset{\sim} s_l$ for a protein resident solely in a particular compartment. The amount of starting material, tmtMS2totProt, ($t_l$) in each fraction is as follows:

```{r, echo=TRUE, eval=TRUE}

totProtUse <- tmtMS2totProt
totProtUse

totProtdf <- data.frame(t(matrix(totProtUse)))
names(totProtdf) <- colnames(markerLocR)
totProtdf
```

We denote these values using a vector ${\bf t} = (t_1, t_2, \dots, t_9)$. The total amount of starting material ${{t}_{h}}=\sum\limits_{i=1}^{6}{{{t}_{i}}}$ is the sum of the amounts given in the first six (differential) fractions (N, M, L1, L2, P, and S).

```{r, echo=TRUE, eval=TRUE}
sum(totProtUse[1:6])
```

(The last three "Nyc" columns were derived from L1, so we do not include them in the sum.)

The next step is to compute the amount of protein in each fraction fraction by multiplying the normalized specific amount by the total protein. Thus for protein $\alpha$ in fraction $l$, we have ${{a}_{\alpha ,l}}={{\tilde{s}}_{\alpha ,l}}{{t}_{l}}$. In matrix form,

$$\mathbf{A}=\mathbf{\tilde{S}}\cdot \text{diag}(\mathbf{t})=\left[ \begin{matrix}
   {{{\tilde{s}}}_{11}}{{t}_{1}} & {{{\tilde{s}}}_{12}}{{t}_{2}} & \cdots  & {{{\tilde{s}}}_{19}}{{t}_{9}}  \\
   {{{\tilde{s}}}_{21}}{{t}_{1}} & {{{\tilde{s}}}_{22}}{{t}_{2}} & \cdots  & {{{\tilde{s}}}_{29}}{{t}_{9}}  \\
   \vdots  & \vdots  & {} & \vdots   \\
   {{{\tilde{s}}}_{n1}}{{t}_{1}} & {{{\tilde{s}}}_{n2}}{{t}_{2}} & \cdots  & {{{\tilde{s}}}_{n9}}{{t}_{9}}  \\
\end{matrix} \right]$$

We need this matrix to do the next step, which is to convert to a common scale for all proteins. We do this by normalizing to the amount of protein $\alpha$ in the starting material, which we denote as $a_{\alpha, h}$. In some experiments, if the homogenate is measured directly, this can be calculated from ${{s}_{\alpha ,h}}{{t}_{h}}$.
Alternatively, if a complete set of fractions that entirely represent the homogenate are available, it is preferable to calculate this by summing $s_{\alpha,l}t_l$ over these fractions. In our case, the first six fractions represent a complete set of differential fractions, and thus ${{a}_{\alpha ,h}}=\sum\nolimits_{i=1}^{6}{{{s}_{\alpha ,i}}{{t}_{i}}}$. Finally, we normalize amounts in any given fraction to amounts in starting material, which we call the relative amount and denote as ${{\overset{\scriptscriptstyle\smile}{a}}_{\alpha ,l}}$. In our example, 

$${{\overset{\scriptscriptstyle\smile}{a}}_{\alpha ,l}}=\frac{{{s}_{\alpha ,l}}{{t}_{l}}}{{{s}_{\alpha ,h}}{{t}_{h}}}=\frac{{{s}_{\alpha ,l}}{{t}_{l}}}{\sum\nolimits_{i=1}^{6}{{{s}_{\alpha ,i}}{{t}_{i}}}}=\frac{{{{\tilde{s}}}_{\alpha ,l}}{{t}_{l}}}{\sum\nolimits_{i=1}^{6}{{{{\tilde{s}}}_{\alpha ,i}}{{t}_{i}}}}$$
In matrix form, we may write this as 
${\bf{\mathord{\buildrel{\lower3pt\hbox{$\scriptscriptstyle\smile$}}\over 
 A} }} = {\bf{A}} \cdot {\rm{diag}}(1/{a_{\alpha ,h}}) = \left[ {\matrix{
   {{s_{11}}{t_1}/{a_{1,h}}} & {{s_{12}}{t_2}/{a_{1,h}}} &  \cdots  & {{s_{19}}{t_9}/{a_{1,h}}}  \cr 
   {{s_{21}}{t_1}/{a_{2,h}}} & {{s_{22}}{t_2}/{a_{2,h}}} &  \cdots  & {{s_{29}}{t_9}/{a_{2,h}}}  \cr 
    \vdots  &  \vdots  & {} &  \vdots   \cr 
   {{s_{n1}}{t_1}/{a_{n,h}}} & {{s_{n2}}{t_2}/{a_{n,h}}} &  \cdots  & {{s_{n9}}{t_9}/{a_{n,h}}}  \cr 

 } } \right]$


$$\mathbf{\overset{\scriptscriptstyle\smile}{A}}=\mathbf{A}\cdot \text{diag}(1/{{a}_{\alpha ,h}})=\left[ \begin{matrix}
   {{s}_{11}}{{t}_{1}}/{{a}_{1,h}} & {{s}_{12}}{{t}_{2}}/{{a}_{1,h}} & \cdots  & {{s}_{19}}{{t}_{9}}/{{a}_{1,h}}  \\
   {{s}_{21}}{{t}_{1}}/{{a}_{2,h}} & {{s}_{22}}{{t}_{2}}/{{a}_{2,h}} & \cdots  & {{s}_{29}}{{t}_{9}}/{{a}_{2,h}}  \\
   \vdots  & \vdots  & {} & \vdots   \\
   {{s}_{n1}}{{t}_{1}}/{{a}_{n,h}} & {{s}_{n2}}{{t}_{2}}/{{a}_{n,h}} & \cdots  & {{s}_{n9}}{{t}_{9}}/{{a}_{n,h}}  \\
\end{matrix} \right]$$


or simply as $\mathbf{\overset{\scriptscriptstyle\smile}{A}}=\left( {{{\overset{\scriptscriptstyle\smile}{a}}}_{\alpha ,l}} \right)$. The function abundanceTransform compoutes this:



```{r, echo=TRUE, eval=TRUE}

protAbund <- relAmtTransform(markerLocR,6,3, totProt=totProtUse)
Acup <- protAbund$Acup
round(Acup, digits=4)
```

The values in "relAmtProtFrac" represent the amount of protein per fraction, normalized to same amount of protein in the starting material (before mixing). In theory, these values correspond approximately to the relative amounts of protein in compartments within a cell.

##Relative Specific Amounts

When examining the distribution of a given protein in different fractions, it is particularly useful to consider its abundance relative to that of total protein.  We refer to this as a Relative Specific Amount (RSA or $r$), which can be calculated as $r_l = \overset{\sim} a_l / t_l$. This describes the fold-enrichment ($r>1$) or depletion ($r<1$) of a protein during the fractionation process, and is analogous to the relative specific activity term used in classical analytical subcellular fractionation.

Then the Relative Specific Amount (RSA) values represent the degree of enrichment or depletion of a protein in a given fraction compared to the amount in the starting material. For a protein $\alpha$ the RSA in fraction $l$ is given by




${{r}_{\alpha ,l}}=\frac{{{{\overset{\scriptscriptstyle\smile}{a}}}_{\alpha ,l}}}{{{{\overset{\scriptscriptstyle\smile}{t}}}_{l}}}=\frac{{{s}_{\alpha ,l}}\cdot \sum\nolimits_{j}^{k}{{{t}_{i}}}}{\sum\nolimits_{j}^{k}{{{s}_{\alpha ,l}}{{t}_{i}}}}$

In matrix form, this is $\mathbf{R}=\left( {{r}_{\alpha ,l}} \right)$.

In "protlocassign", we get the RSA matrix from "relAmtProtFrac" and "totProt" as follows:


```{r, echo=TRUE, eval=TRUE}
rsa <- RSAfromAcup(Acup, totProt=totProtUse)
round(rsa, digits=4)
```

Finally, if we normalize the rsa matrix so that rows sum to one (via the "apply" function), we get original input data, markerLocR
```{r, echo=TRUE, eval=TRUE}
round(t(apply(rsa,1, function(x) x/sum(x))), digits=4)
```

If we just need to obtain the RSA transformed data directly, just do this:
```{r, echo=TRUE, eval=TRUE}
markerLocRrsa <- RSAfromS(SS=markerLocR, nDiffFractions=6, nNycFractions=3,
        totProt=totProtUse)

round(markerLocRrsa, digits=4)
```

## Simulating proteins resident in multiple subcellular locations

We may simulate data from proteins with multiple residences using the "proteinMix" function. For example, to simulate date from proteins resident in a range of proportions in cytosol and lysosomes, we do this:
```{r, echo=TRUE, eval=TRUE}
#totProt=c(46.044776, 48.955954, 1.384083, 1.566324, 24.045584, 58.181818, 0.0368564, 0.0684596, 1.27301587)

protAbund <- relAmtTransform(markerLocR, nDiffFractions=6, nNycFractions=3 , totProt=totProtUse)
Acup <- protAbund$Acup
mixCytoLyso <- proteinMix(Acup, 1, 4)
round(mixCytoLyso, digits=4)
```

Then we can test the CPA algorithm by first converting this mixture data to RSA's:
```{r, echo=TRUE, eval=TRUE}

mixCytoLysoRSA <- RSAfromAcup(Acup=mixCytoLyso, nDiffFractions=6, nNycFractions=3, totProt=totProtUse)

mixCytoLysoRelAmt <- data.frame(rownames(mixCytoLysoRSA), mixCytoLysoRSA)
names(mixCytoLysoRelAmt)[1] <- "protName"
round(mixCytoLysoRelAmt[,-1], digits=4)

#markerLocRrsa <- rsaDirect(protProfileLevels=markerLocR, totProt=totProt)
markerLocRrsa <- RSAfromS(SS=markerLocR, nDiffFractions=6, nNycFractions=3, totProt=totProtUse)
rownames(markerLocRrsa) <- rownames(markerLocR)
```
Finally, we fit the CPA algorithm to this RSA-transformed, simulated data:

```{r, echo=TRUE, eval=TRUE}
mixCytoLysoPropT <- proLocAll(protProfileSummary=mixCytoLysoRelAmt, markerLocR=markerLocRrsa,
                            n.channels=9)
mixCytoLysoProp <- mixCytoLysoPropT[,-c(1,10)]
row.names(mixCytoLysoProp) <- mixCytoLysoPropT[,1]
round(mixCytoLysoProp, digits=3)

```
The estimated proportions correspond closely to the the proportions used in the simulation.




## References


Jadot M, Boonen M, Thirion J, Wang N, Xing J, Zhao C, Tannous A, Qian M, Zheng H, Everett JK, Moore DF, Sleat DE, Lobel P (2016) Accounting for protein subcellular localization: a compartmental map of the rat liver proteome. Molecular and Cellular Proteomics 16, 194-212. doi:10.1074/mcp.M116.064527  PMCID: PMC5294208

Tannous A, Boonen M, Zheng H, Zhao C, Germain C, Moore D, Sleat D, Jadot M, Lobel P. Comparative Analysis of Quantitative Mass Spectrometric Methods for Subcellular Proteomics. Journal of Proteome Research 19, 1718-1730.
doi.org/10.1021/acs.jproteome.9b00862


