---
title: "Data Transformations Using protlocassign"
author: "Dirk Moore"
date: "`r Sys.Date()`"
#output: rmarkdown::html_vignette
output:
  #mathjax:  default
  #  html_document:
  word_document:
  fig_caption:  true
  toc: true
#section_numbering: true
#css: ggsci.css
#output:
#  word_document:
#    reference_docx: word-styles-reference-03.docx
#output: pdf_document
#fontsize: 10pt
vignette: >
  %\VignetteIndexEntry{protlocassign}
  %\VignetteEngine{knitr::rmarkdown}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```
## Data transformations

In the tutorial we illustrated the principles of constrained proportional assignment based
on amounts of protein in each of a number of channels, corresponding generally to the amounts
of protein in differential fractions. In reality, though, the connection between relative levels
in channels and the relative protein levels in the differential fracitions, and of that to the
relative amounts of protein in subcellular locations within the cell is complex. This vignette
describes how to use functions in the protlocassign package to transform relative amounts of
protein in the fractions to amounts more useful for inferring relative proportions in subcellular
comparments.


## Loading the data

As explained in the "Getting Started" vignette, you will need two data sets. One consists of a column of protein names followed by a series of columns of relative protein levels derived from a subcellular fractionation experiment. (Optionally there may be two additional columns representing the numbers of peptides and spectra that were used to compute mean protein abundance levels.) The other data set consists of a list of reference proteins in the first column and the name of the known subcellular compartment in the second column.

Also explained previously, we Consider the TMT MS2 data from Tannous et al. (2020). 
They
presented abundance levels of proteins among seven fractions: N, M, L1, L2, P, and S,
and three additional fractions, "Nyc1", Nyc2", and "Nyc3", from Nycodenz fractions.
Eight subcellular compartments were considered: nucleus, mitochondria, lysosomes,
peroxisomes, golgi apparatus, plasma membrane, and cytosol.
The CPA method assigns each of a large number of proteins to one or more of
these compartments, based on profiles from a set of reference proteins.
To run the program, the `prolocate` library must be installed.
Also, the `BB` library is required; it may be downloaded from CRAN by typing
`install.packages("BB") `.


```{r, echo=TRUE}
library(protlocassign)
dim(protProfileSummaryTMTms2)
options(digits=3)
head(protProfileSummaryTMTms2)
```
The data set gives relative fraction levels for 7893 proteins.
The last two columns give the number of spectra and the number of peptides
(sequences) for each protein. (The spectra were averaged using a
nested random effects model described in Jadot, 2016, to produce the given average
for each protein.)

The second data set we need has 39 reference proteins and two columns, the first for the protein name and the second for their respective subcellular compartments. These are from Jadot et al (2016) and may be viewed as follows:

```{r, echo=TRUE}
dim(refLocProteinsJadot)
refLocProteinsJadot
```
There are 39 proteins in this reference set.

To obtain profiles for the reference proteins, use the function `cpaSetup`:

```{r, echo=TRUE, eval=TRUE}
markerLocRuse <- cpaSetup(protProfileSummary=protProfileSummaryTMTms2, refLocProteins=refLocProteinsJadot, n.channels=9)
markerLocRuse

```


It is possible to use these two data sets as is to find constrained proportional estimates; with data from other experiments, this may in fact be the only choice. However, in experiments such as Tannous et al. (2020), which use bookkeeping, it is preferable to
transform them to relative specific activities (RSA's), which are the amount
of a given protein in a fraction divided by the amount of starting material of
that protein (see Appendix section on adjusting protein levels).
These adjustment factors are in the dataset "tmtMS2totProt",
which is just a vector of length 9:

```{r, echo=TRUE, eval=TRUE, fig.show='hold'}
totProtUse <- tmtMS2totProt
totProtUse
```

The program "rsaDirect" adjusts the fraction levels measured from the machine to the
amounts of protein in each fraction in the original sample.
It is important to specify how many of the fractions are Nycodenz fractions
(three in this case) so that the adjustment is just using the differential fracctions.
We do this first with the reference profile levels in "markerLocR":

```{r, echo=TRUE, eval=TRUE, fig.show='hold'}
markerLocRrsa <- rsaDirect(protProfileLevels=markerLocRuse, nDiffFractions=6,
       nNycFractions=3, totProt=totProtUse)
row.names(markerLocRrsa) <- row.names(markerLocRuse)

```

We now do the same for the matrix of protein-level mean profiles:

```{r, echo=TRUE, eval=TRUE, fig.show='hold'}
protProfileLevelsUse <- protProfileSummaryTMTms2[,2:(1 + 9)]
protProfileLevelsRSA <- rsaDirect(protProfileLevels=protProfileLevelsUse,
                                   nDiffFractions=6, nNycFractions=3, totProt=totProtUse)
dim(protProfileLevelsRSA)
head(protProfileLevelsRSA)
```

Now we put back the protein names in the first column, and Nspectra and Nseq in the last columns:

```{r, echo=TRUE, eval=TRUE, fig.show='hold'}
protProfileSummaryRSA <- data.frame(protProfileSummaryTMTms2[,1],protProfileLevelsRSA,
                                    protProfileSummaryTMTms2[,11:12])
names(protProfileSummaryRSA)[1] <- "protName"
dim(protProfileSummaryRSA)
head(protProfileSummaryRSA)
```

Now we can plot the reference profile for any subcellular location on the RSA scale. For
example, here is the plot for PM:

```{r, echo=TRUE, eval=TRUE, fig.show='hold'}
#par(mfrow=c(4,3))
refProfilePlot(refLoc="PM", refLocProteins=refLocProteinsJadot,
                     protProfileSummary=protProfileSummaryRSA,
                     markerLocR=markerLocRrsa)

```

Now we can run the CPA routine on the RSA-transformed levels; this may take several minutes to complete. The last column is a convergence indicator, with 1 indicating successful convergence. We remove this last column to get a matrix of protein names, and columns indicating the estimated proportional assignments of each protein among the eight subcellular locations.

```{r, echo=TRUE, eval=TRUE}
assignPropsOutTemp <- proLocAll(protProfileSummary=protProfileSummaryRSA,
                                markerLocR=markerLocRrsa, n.channels=9)
ncol.a <- ncol(assignPropsOutTemp)   # last column is a convergence indicator, which should be 1
assignPropsUse <- data.frame(assignPropsOutTemp[,-ncol.a] ) # drop this last column
head(assignPropsUse)
```



Next, load the original data, with spectra and peptides, and select the columns for protein name, peptide name, and the nine fractions ranging from N to Nyc.3:

```{r, echo=TRUE, eval=TRUE}
#finalListUse <- subset(tmtMS2orig, select={c(prot:peptide,N:Nyc.3)}, subset={prot %in% protsInclude})
finalListUse <- subset(tmtMS2orig, select={c(prot:peptide,N:Nyc.3)})
```

To convert to relative specific values, we convert this large dataframe in five smaller pieces, convert those pieces, and then reassemble:

```{r, echo=TRUE, eval=TRUE}
finalListRSAuse1 <- rsaDirect(protProfileLevels=finalListUse[1:30000,3:11],
                                   nDiffFractions=6, nNycFractions=3, totProt=totProtUse)
finalListRSAuse2 <- rsaDirect(protProfileLevels=finalListUse[30001:60000,3:11],
                                   nDiffFractions=6, nNycFractions=3, totProt=totProtUse)
finalListRSAuse3 <- rsaDirect(protProfileLevels=finalListUse[60001:90000,3:11],
                                   nDiffFractions=6, nNycFractions=3, totProt=totProtUse)
finalListRSAuse4 <- rsaDirect(protProfileLevels=finalListUse[90001:120000,3:11],
                                   nDiffFractions=6, nNycFractions=3, totProt=totProtUse)
finalListRSAuse5 <- rsaDirect(protProfileLevels=finalListUse[120001:nrow(finalListUse),3:11],
                                   nDiffFractions=6, nNycFractions=3, totProt=totProtUse)
finalListRSAuseT <- rbind(finalListRSAuse1, finalListRSAuse2, finalListRSAuse3, finalListRSAuse4, finalListRSAuse5)

finalListRSAuse <- data.frame(finalListUse[,1:2], finalListRSAuseT)

```
We can look at the profile of, for example, the protein "AADAC" by first finding the protein number in the dataset:

```{r, echo=TRUE, eval=TRUE}
protIndex("AADAC")
#protPlotfun(protPlot=93, assignProbsOut=assignProbsOut)
```
This function also accepts partial matching of the first few letters of a protein. For example, we can find the indices of the proteinss starting with "AAD""
```{r, echo=TRUE, eval=TRUE}
protIndex("AAD")
```
Now we plot the results for protein AADAC:

```{r, echo=TRUE, eval=TRUE, fig.width=7, fig.height=7}

protPlotfun(protName="AADAC", protProfileSummary=protProfileSummaryRSA, finalList=finalListRSAuse, n.fractions=9,
                        Nspectra=T, markerLocR=markerLocRrsa, assignPropsMat=assignPropsUse)
```

The horizontal axis represents the nine fractions, which are N, M, L1, L2, P, S, Nyc.1, Nyc.2, and Nyc.3. In each of the eight plots, the red line is the average profile of the peptides, which are represented by the blue lines; thicker blue lines indicate larger numbers of spectra for a particular peptide. The dashed yellow-black lines show the expected profile for a protein entirely resident in the respective subcellular location. In this set of plots, we see that the CPA procedure assigns a 92\% residence proportion to endoplasmic reticulum. Visually, we see that the observed red profile closely matches the expected yellow-black profile for endoplasmic reticulum.

## Nearest proteins in a data set
We may find the proteins with profiles nearest to a given protein using the function "nearestProts". Distance is computed as the Euclidean distance between profiles. To use the function, we first create a distance matrix for the proteins in a list of mean profiles, such as "protProfileSummaryTMTms2". In this dataset, the profiles are in columns 2 through 10.

```{r, echo=TRUE, eval=TRUE}
distUse <- dist(protProfileSummaryTMTms2[,2:10], method="euclidean")
```
Then select the protein names:

```{r, echo=TRUE, eval=TRUE}
protsUse <- protProfileSummaryTMTms2[,1]
```
Finally, provide a protein name. Here, for the protein "AADAC", we find the 10 nearest proteins.

```{r, echo=TRUE, eval=TRUE}
protIndex("AAD")
nearestProts("AADAC", n.nearest=10,  distProts=distUse, protNames=protsUse)
```



# Appendix
## Outlier rejection and computation of mean profiles

The profiles of some compartments (e.g. nuclear and mitochondrial) show a high relative abundance level in the N or M fractions, respectively, and little in the others. Cytosolic proteins also are high in one fraction (S) and low in the others. Peroxisomes have high activity levels in the L1 and L2 fractions, and low levels in the others, including Nyc2. Lysosomes, like peroxisomes, have high level in the L1 and L2 fractions, but, unlike peroxisomes, high levels in Nyc2. The other compartments (ER, Golgi, and PM) have more complex profiles. Once we have obtained reference profiles for each of the eight compartments, we score each new protein as the optimal combination of the reference proteins, thereby obtaining estimates of the proportionate contributions of each reference profile to that of the protein being considered.


The first step is an outlier screen, for each protein, of the abundance levels for each fraction of all of the spectra. Abundance levels $p$ are first log2 transformed via $y = log_2(p + \delta)$, where $\delta$ is an estimate of the background "noise" in the abundance estimates. Here we used $\delta = 10^{(-5)}$. Then boxplot outliers are identified as values more than three times the interquartile range beyond the first or third quartile. We discard any spectrum for which any observation is thereby classified as an outlier. This process is repeated for all proteins.


## Constrained proportional assignment
Once outlier spectra have been removed, the next step is to determine a mean profile for each protein. If a protein has at least 4 spectra and at least 3 different sequences (peptides), we ordinarily have enough data to fit a random effects model. This model computes, for each EF in each fraction of this protein, a weighted average and standard error of the measures, accounting for the fact that spectra are nested within sequences. (This computation is carried out using the “lmer” function in the “lme4” R package.) . The result is essentially the mean and standard error of the observations, with an adjustment for the nested structure of the data. This procedure prevents a sequence with a very large number of spectra from dominating the estimates of the mean and standard error.  Occasionally the “lmer” program will fail to converge for a particular abundance. If that happens or if the condition of having at least 4 spectra and 3 different sequences is not met, we compute the simple mean and standard error of the (log2 transformed) for that abundance level. If there are fewer than 3 spectra, we cannot compute a standard error, and thus only report the mean.  When this process has been completed, every protein has a mean profile which for now we denote as $\underset{\sim}x = (x_1, x_2, ..., x_q)$  of abundance levels in the $q=9$ fractions N, M, L1, L2, P, S, Nyc1, Nyc2, and Nyc3. Below we will see that the abundance levels $x_j$ may be represented as either the amount of species of interest (typically a protein) measured in a channel or, if a process known as bookkeeping has been followed, the relative specific amounts of that species of interest. For proteins with at least 2 peptides and three spectra, each component of the profile has an estimate of its standard deviation.

Next, the profiles of the reference proteins are selected. For each of the eight compartments (Cytosol, ER, Golgi, Lysosome, Mitochondria, Nucleus, Peroxisome, and PM), the reference protein abundance levels are averaged to form eight compartment profiles $\underset{\sim}x^*_1, \underset{\sim}x^*_2, ..., \underset{\sim}x^*_8$, where each vector $\underset{\sim}x^*_j$ is a $q \times 1$ vector of mean levels of the $q=9$ channels.

Finally, for each protein, we find estimated proportions $\hat{p}_1, \hat{p}_2, ..., \hat{p}_8$ so that
$$\underset{\sim}y = \hat{p}_1 \underset{\sim}x^*_1 + ...+ \hat{p}_8 \underset{\sim}x^*_8$$
is as close as possible to the observed value $\underset{\sim}x$, subject to the constraints

$$ 0 \leq \hat{p_j} \leq 1$$

for all $j$, and



$$ \sum_{j=1}^{8} \hat{p}_j = 1 $$
where "close" is defined by minimizing the sum of squares of the differences

$$ Q=\sum_{i=1}^{q}(y_i - x_i)^2 $$
Thus, we may view the proportions $\hat{p}_j$ as proportional allocations of the eight standard profiles to form $\underset{\sim}y$, which is as close as possible to the observed $\underset{\sim}x$ for this particular protein. This constrained optimization is carried out using the “spg” function in the R package “BB” to compute assignment probabilities for each profile for each organelle.

## Adjustment of protein abundance levels

The input data, protProfileSummary, consists of a list of protein names (first column) and the relative abundance (technically, the "specefic amount", which reflects the signal in arbitrary units per unit total protein) of the corresponding proteins in the next columns. Typically, there will be six differential fraction columns (N, M, L1, L2, P, and S) and one to three additional Nycodenz fractions (which have been extracted from the L1 differential fraction). These quantities represent the specific amounts of a protein in each fraction. The amounts (denoted $t_l$) of protein extracted from each fraction, (R variable "totProtein"), differ dramatically from one fraction to another. Notably, the L1 and L2 fractions, which are heavily enriched in lysosomal and peroxixomal proteins, contain much smaller amounts of protein than the other differential fractions. Also, the samples used for the Nycodenz fractionization are taken from the L1 fraction, so they also represent very small proportions of the total sample. For technical reasons, when samples of material are prepared for analysis, equal amounts are select_ed for each channel, regardless of the amount of protein in the fractions. As a result, when the data are analyzed, adjustments need to be made in order to obtain meaningful comparisons. In the introductory vignette we actually used a normalized specific amount $\overset{\sim} s_l$ (generally the amount of signal in that fraction), calculated as follows:

$$\overset{\sim} s_l = {\frac{s_l} {\sum s_i}}$$ 

In some experiments, where bookkeeping is not practicable, these are the only values available for using the CPA procedure. However, with appropriate bookkeeping, the amounts of total protein, $t_l$, are available. We can use these to calculate the amount of protein in fraction $l$ derived from a set amount of starting material as $a_l = s_l t_l$.

  To see how this works in protlocassign, let us consider the Jadot reference protein profiles

```{r, echo=TRUE, eval=TRUE}
markerLocR <- cpaSetup(protProfileSummary=protProfileSummaryTMTms2, refLocProteins=refLocProteinsJadot, n.channels=9)
round(markerLocR, digits=4)

```

Here, each row represents the profile $\overset{\sim} s_l$ for a protein resident solely in a particular compartment. The amount of starting material, tmtMS2totProt, ($t_l$) in each fraction is as follows:

```{r, echo=TRUE, eval=TRUE}

totProtUse <- tmtMS2totProt
totProtUse

totProtdf <- data.frame(t(matrix(totProtUse)))
names(totProtdf) <- colnames(markerLocR)
totProtdf
```

The total amount of starting material $t_h$ is the sum of the amounts given in the first six (differential) fractions (N, M, L1, L2, P, and S).

```{r, echo=TRUE, eval=TRUE}
sum(totProtUse[1:6])
```

(The last three "Nyc" columns were derived from L1.)

To compute the amount of protein in each fraction, we multiply each column by the amount of starting material in each fraction. The function abundanceTransform does this:

```{r, echo=TRUE, eval=TRUE}

protAbund <- abundanceTransform(markerLocR,6,3, totProt=totProtUse)
round(protAbund$amtProtFrac, digits=4)
round(protAbund$relAmtProtFrac, digits=4)
```

The first component of the result, amtProtFrac, is the amount of protein in each fraction for each row. The second component, relAmtProtFrac,
is the amount of given protein in fraction / amount of given protein in starting material. For example, for a cytosolic protein, the amount of protein in each fraction is given by

```{r, echo=TRUE, eval=TRUE}
markerLocR[,1]*totProtUse[1]
protAbund$amtProtFrac[1,]
```
This is the first column of amtProtFrac.

The first row of relAmtProtFrac, to continue with the example, is the first row of amtProtFrac (amount of cystolic protein in each fraction) divided by the total amount of cystolic protein, which is the sum of the first row of amtProtFrac:

```{r, echo=TRUE, eval=TRUE}
protAbund$amtProtFrac[1,] / sum(protAbund$amtProtFrac[1,])
```

The relative amount of a cytosolic protein is given by the amounts of protein in the first row (a cytosolic protein) divided by the amounts in all six differential fractions (the first six elements of the first row):
```{r, echo=TRUE, eval=TRUE}

protAbund$amtProtFrac[1,]/sum(protAbund$amtProtFrac[1,])
protAbund$relAmtProtFrac[1,]
```
This is the first row of relAmtProtFrac.

The values in relAmtProtFrac represent the amount of protein per fraction, normalized to same amount of protein in the starting material (before mixing). In theory, these values correspond approximately to the relative amounts of protein in compartments within a cell.

Finally, we compute $r_l = \overset{\sim} a_l / t_l$, the relative specific amounts (RSA) as follows:

We first find $t_h$ (Difp), the total protein in the six differential fractions (nDiffFractions = 6), and then the proportions propFrac of protein in the differential fractions:
```{r, echo=TRUE, eval=TRUE}
rsaResult <- RSAtransform(protAbund$relAmtProtFrac, totProt=totProtUse)
round(rsaResult$rsa, digits=4)
```

```{r, echo=TRUE, eval=TRUE}
Difp <- sum(totProtUse[1:6])   # total protein in the differential fractions
Difp
propFrac <- totProtUse/Difp  # proportion of protein in the differential fractions
propFrac
```

For example, for the N fraction (first column), we have, which matches the first column of rsa:
```{r, echo=TRUE, eval=TRUE}
protAbund$relAmtProtFrac[,1]/propFrac[1]
rsaResult$rsa[,1]
```

Finally, if we normalize the rsa matrix so that rows sum to one, we get original input data, markerLocR
```{r, echo=TRUE, eval=TRUE}
round(rsaResult$rsaFractions, digits=4)
round(markerLocR, digits=4)
```

If we just need to obtain the RSA transformed data directly, just do this:
```{r, echo=TRUE, eval=TRUE}
markerLocRrsa <- rsaDirect(protProfileLevels=markerLocR, nDiffFractions=6, nNycFractions=3,
        totProt=totProtUse)

round(markerLocRrsa, digits=4)
```

## Simulating proteins resident in multiple subcellular locations

We may simulate data from proteins with multiple residences using the "proteinMix" function. For example, to simulate date from proteins resident in a range of proportions in cytosol and lysosomes, we do this:
```{r, echo=TRUE, eval=TRUE}
#totProt=c(46.044776, 48.955954, 1.384083, 1.566324, 24.045584, 58.181818, 0.0368564, 0.0684596, 1.27301587)

protAbund <- abundanceTransform(markerLocR, nDiffFractions=6, nNycFractions=3 , totProt=totProtUse)
relAmtProtFrac <- protAbund$relAmtProtFrac
mixCytoLyso <- proteinMix(relAmtProtFrac, 1, 4)
round(mixCytoLyso, digits=4)
```

Then we can test the CPA algorithm by first converting this mixture data to RSA's:
```{r, echo=TRUE, eval=TRUE}

mixCytoLysoRSA <- RSAtransform(relAmtProtFrac=mixCytoLyso, nDiffFractions=6, nNycFractions=3, totProt=totProtUse)$rsa

mixCytoLysoRelAmt <- data.frame(rownames(mixCytoLysoRSA), mixCytoLysoRSA)
names(mixCytoLysoRelAmt)[1] <- "protName"
round(mixCytoLysoRelAmt[,-1], digits=4)

#markerLocRrsa <- rsaDirect(protProfileLevels=markerLocR, totProt=totProt)
markerLocRrsa <- rsaDirect(protProfileLevels=markerLocR, nDiffFractions=6, nNycFractions=3, totProt=totProtUse, maxRSA=25)
rownames(markerLocRrsa) <- rownames(markerLocR)
```
Finally, we fit the CPA algorithm to this RSA-transformed, simulated data:

```{r, echo=TRUE, eval=TRUE}
mixCytoLysoPropT <- proLocAll(protProfileSummary=mixCytoLysoRelAmt, markerLocR=markerLocRrsa,
                            n.channels=9)
mixCytoLysoProp <- mixCytoLysoPropT[,-c(1,10)]
row.names(mixCytoLysoProp) <- mixCytoLysoPropT[,1]
round(mixCytoLysoProp, digits=4)

```
The estimated proportions correspond closely to the the proportions used in the simulation.

## References


Jadot M, Boonen M, Thirion J, Wang N, Xing J, Zhao C, Tannous A, Qian M, Zheng H, Everett JK, Moore DF, Sleat DE, Lobel P (2016) Accounting for protein subcellular localization: a compartmental map of the rat liver proteome. Molecular and Cellular Proteomics 16, 194-212. doi:10.1074/mcp.M116.064527  PMCID: PMC5294208

Tannous A, Boonen M, Zheng H, Zhao C, Germain C, Moore D, Sleat D, Jadot M, Lobel P. Comparative Analysis of Quantitative Mass Spectrometric Methods for Subcellular Proteomics. Journal of Proteome Research 2020.


